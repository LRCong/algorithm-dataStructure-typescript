# algorithm-dataStructure-typescript
Typescript实现的各种基础算法与数据结构
> 参考资料：《算法第四版》

大纲:
+ 第一章 通用排序
  + 插入排序
  + 选择排序
  + 希尔排序
  + 归并排序
  + 快速排序
  + 堆排序（优先队列）
+ 查找
  + 符号表
  + 二叉查找树
  + 平衡查找树
  + 散列表
+ 图
  + 最小生成树
  + 最短路径
+ 字符串
  + KMP
  + BM
  + RK
  + 正则表达式
+ 动态规划

## 第一章 通用排序
#### 基础的排序算法：插入排序和选择排序
选择排序的特点是无论数组是否部分有序，比较次数都不变，而插入排序可以有效应对部分有序数组
#### 希尔排序
为了优化插入排序对大规模无序数组的排序效率，引入希尔排序
#### 两种经典NlogN排序
归并排序至多6NlogN次比较，快速排序是适用性很强的排序算法
#### 堆排序
堆（优先队列）这种数据结构可以有效应对一些场景，比如任务调度，基于堆的堆排序是一种优雅的排序算法。
##### 加入针对数字的桶排序、基数排序等将在未来加入

## 第二章 查找表
#### 符号表
用线性表存储键值对，分为有序符号表和无序符号表两类。无序符号表插入时间复杂度为O(1)，但是查找复杂度为O(n)，而有序符号表经过二分查找算法优化后，插入和查找复杂度都为O(logn)。
#### 二叉查找树
利用树存储键值对，每个节点有两个直接子节点，左边后代键均小于自己的键，右边则都大于。
插入和查找都可以实现O(logn)复杂度，但是容易出现不平衡问题。
#### 红黑树
由23树演变而来，解决二叉查找树容易不平衡的问题。查找或过程中，比较次数最多的情况不会超过比较次数最少情况的两倍。
#### 散列表
插入和查找都可以实现O(1)复杂度的数据结构，存在的问题是哈希冲突，有两种解决方法：拉链法和线性探测法。